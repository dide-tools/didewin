---
title: "Package installation"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 2
vignette: >
  %\VignetteIndexEntry{Package installation}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

<!-- DO NOT EDIT THIS FILE - see vignettes_src and make changes there -->



Often the most difficult part of configuring your cluster jobs is sorting out all the packages that you need and making sure that they are present on the cluster. There are several levels of difficulty here and this document will walk through them in turn.

## Everything is on CRAN

This is the most straightforward situation - all your packages are on CRAN. You don't need to do anything special typically, just create your context with a list of packages and create the queue:


```r
root <- "pkgs"
ctx <- context::context_save(root, packages = c("dplyr", "ggplot2"))
#> [ init:id   ]  56d34997c3c968cfaa337d18c74c552c
#> [ init:db   ]  rds
#> [ init:path ]  pkgs
#> [ save:id   ]  38f5f51a1f561e2d730e50b7268301a4
#> [ save:name ]  unexistential_billygoat
obj <- didehpc::queue_didehpc(ctx)
#> Loading context 38f5f51a1f561e2d730e50b7268301a4
#> [ context   ]  38f5f51a1f561e2d730e50b7268301a4
#> [ library   ]  dplyr, ggplot2
#>
#> Attaching package: 'dplyr'
#> The following objects are masked from 'package:stats':
#>
#>     filter, lag
#> The following objects are masked from 'package:base':
#>
#>     intersect, setdiff, setequal, union
#> [ namespace ]
#> [ source    ]
#> Running installation script on cluster
#>   ,:\      /:.
#>  //  \_()_/  \\
#> ||   |    |   ||  CONAN THE LIBRARIAN
#> ||   |    |   ||  Library:   Q:\didehpc\20210420-102851\pkgs\lib\windows\4.0
#> ||   |____|   ||  Bootstrap: T:\conan\bootstrap\4.0
#>  \\  / || \  //   Cache:     Q:\didehpc\20210420-102851\pkgs\conan\cache/pkg
#>   `:/  ||  \;'    Policy:    lazy
#>        ||         Repos:
#>        ||           * https://mrc-ide.github.io/didehpc-pkgs
#>        XX           * https://cloud.r-project.org
#>        XX         Packages:
#>        XX           * context
#>        XX           * dplyr
#>        OO           * ggplot2
#>        `'
#> i Loading metadata database
#> v Loading metadata database ... done
#> i Getting 36 pkgs (27.70 MB) and 1 pkg with unknown size
#> v Got askpass 1.1 (windows) (243.57 kB)
#> v Got crayon 1.4.1 (windows) (141.72 kB)
#> v Got R6 2.5.0 (windows) (84.10 kB)
#> v Got digest 0.6.27 (windows) (268.60 kB)
#> v Got context 0.3.0 (source) (37.72 kB)
#> v Got ids 1.0.1 (windows) (123.91 kB)
#> v Got sys 3.4 (windows) (59.68 kB)
#> v Got uuid 0.1-4 (windows) (33.77 kB)
#> v Got ellipsis 0.3.1 (windows) (46.15 kB)
#> v Got generics 0.1.0 (windows) (70.84 kB)
#> v Got lifecycle 1.0.0 (windows) (111.22 kB)
#> v Got openssl 1.4.3 (windows) (3.99 MB)
#> v Got glue 1.4.2 (windows) (155.42 kB)
#> v Got cli 2.4.0 (windows) (504.14 kB)
#> v Got pkgconfig 2.0.3 (windows) (22.08 kB)
#> v Got magrittr 2.0.1 (windows) (235.68 kB)
#> v Got storr 1.2.5 (windows) (401.10 kB)
#> v Got dplyr 1.0.5 (windows) (1.33 MB)
#> v Got tibble 3.1.0 (windows) (825.59 kB)
#> v Got tidyselect 1.1.0 (windows) (203.17 kB)
#> v Got utf8 1.2.1 (windows) (209.84 kB)
#> v Got RColorBrewer 1.1-2 (windows) (55.55 kB)
#> v Got purrr 0.3.4 (windows) (426.90 kB)
#> v Got rlang 0.4.10 (windows) (1.20 MB)
#> v Got pillar 1.6.0 (windows) (1.02 MB)
#> v Got ggplot2 3.3.3 (windows) (4.07 MB)
#> v Got labeling 0.4.2 (windows) (62.73 kB)
#> v Got gtable 0.3.0 (windows) (434.20 kB)
#> v Got farver 2.1.0 (windows) (1.75 MB)
#> v Got vctrs 0.3.7 (windows) (1.25 MB)
#> v Got munsell 0.5.0 (windows) (244.85 kB)
#> v Got scales 1.1.1 (windows) (557.57 kB)
#> v Got withr 2.4.1 (windows) (209.25 kB)
#> v Got fansi 0.4.2 (windows) (224.19 kB)
#> v Got isoband 0.2.4 (windows) (3.06 MB)
#> v Got colorspace 2.0-0 (windows) (2.65 MB)
#> v Got viridisLite 0.4.0 (windows) (1.30 MB)
#> v Installed crayon 1.4.1  (969ms)
#> v Installed askpass 1.1  (1.3s)
#> v Installed R6 2.5.0  (2s)
#> v Installed ids 1.0.1  (1.7s)
#> v Installed sys 3.4  (1.8s)
#> v Installed storr 1.2.5  (2.2s)
#> v Installed digest 0.6.27  (2.6s)
#> v Installed openssl 1.4.3  (2.9s)
#> v Installed uuid 0.1-4  (2.2s)
#> i Building context 0.3.0
#> v Installed cli 2.4.0  (9.3s)
#> v Installed dplyr 1.0.5  (9.4s)
#> v Installed ellipsis 0.3.1  (9.4s)
#> v Installed fansi 0.4.2  (9.4s)
#> v Installed generics 0.1.0  (9.4s)
#> v Installed glue 1.4.2  (9.2s)
#> v Installed lifecycle 1.0.0  (9.1s)
#> v Installed pkgconfig 2.0.3  (1.4s)
#> v Installed magrittr 2.0.1  (2.2s)
#> v Installed purrr 0.3.4  (2.5s)
#> v Installed rlang 0.4.10  (2.6s)
#> v Installed pillar 1.6.0  (3.2s)
#> v Built context 0.3.0 (5.7s)
#> v Installed tibble 3.1.0  (2.9s)
#> v Installed tidyselect 1.1.0  (2.3s)
#> v Installed utf8 1.2.1  (2.4s)
#> v Installed vctrs 0.3.7  (1.9s)
#> v Installed RColorBrewer 1.1-2  (1.6s)
#> v Installed farver 2.1.0  (1.4s)
#> v Installed context 0.3.0  (1.6s)
#> v Installed gtable 0.3.0  (922ms)
#> v Installed labeling 0.4.2  (938ms)
#> v Installed ggplot2 3.3.3  (1.8s)
#> v Installed munsell 0.5.0  (1.3s)
#> v Installed colorspace 2.0-0  (3.7s)
#> v Installed scales 1.1.1  (1.6s)
#> v Installed isoband 0.2.4  (2.2s)
#> v Installed withr 2.4.1  (1.3s)
#> v Installed viridisLite 0.4.0  (1.5s)
#> v Summary:   37 new   5 kept  in 2m 9.9s
#> Done!
```

What happened above was when the queue started up it looked to see what packages were available (none were) and then installed everything needed to run your jobs. That includes the two packages listed above but also all their dependencies and [`context`](https://mrc-ide.github.io/context/) which `didehpc` uses to send the jobs back and forth.

All these packages are installed into a special directory within the context root:


```r
dir(file.path(root, "lib/windows", as.character(getRversion()[1, 1:2])))
#>  [1] "R6"           "RColorBrewer" "_cache"       "askpass"      "cli"
#>  [6] "colorspace"   "context"      "crayon"       "digest"       "dplyr"
#> [11] "ellipsis"     "fansi"        "farver"       "generics"     "ggplot2"
#> [16] "glue"         "gtable"       "ids"          "isoband"      "labeling"
#> [21] "lifecycle"    "magrittr"     "munsell"      "openssl"      "pillar"
#> [26] "pkgconfig"    "purrr"        "rlang"        "scales"       "storr"
#> [31] "sys"          "tibble"       "tidyselect"   "utf8"         "uuid"
#> [36] "vctrs"        "viridisLite"  "withr"
```

Everything in this library will be available to your R jobs when they run.

## Everything is available in a CRAN-like repo

We keep many often-used packages in a semi-stable repository (see the [mrc-ide drat](https://mrc-ide.github.io/drat/), the [ncov drat](https://ncov-ic.github.io/drat/) and the more experimental [R-universe](https://mrc-ide.r-universe.dev/ui#builds) system that is being developed to support this sort of workflow in future).

To tell `didehpc` to look in one of these repositories when installing, create a `conan::conan_sourcs` object and list additional repositories as the `repos` argument, and pass this object in as the `package_sources` argument to `context_save`.  Here, we add the mrc-ide drat repository and install the `dde` package; this will use the development version which is often ahead of the CRAN version.


```r
src <- conan::conan_sources(NULL, repos = "https://mrc-ide.github.io/drat/")
ctx <- context::context_save(root, packages = "dde", package_sources = src)
#> [ open:db   ]  rds
#> [ save:id   ]  4dec7a1d5434eb725305ad4e3da5cbc1
#> [ save:name ]  unfair_whoopingcrane
```

Create the library as before, and `dde` will be installed


```r
obj <- didehpc::queue_didehpc(ctx)
#> Loading context 4dec7a1d5434eb725305ad4e3da5cbc1
#> [ context   ]  4dec7a1d5434eb725305ad4e3da5cbc1
#> [ library   ]  dde
#> [ namespace ]
#> [ source    ]
#> Running installation script on cluster
#>   ,:\      /:.
#>  //  \_()_/  \\
#> ||   |    |   ||  CONAN THE LIBRARIAN
#> ||   |    |   ||  Library:   Q:\didehpc\20210420-102851\pkgs\lib\windows\4.0
#> ||   |____|   ||  Bootstrap: T:\conan\bootstrap\4.0
#>  \\  / || \  //   Cache:     Q:\didehpc\20210420-102851\pkgs\conan\cache/pkg
#>   `:/  ||  \;'    Policy:    lazy
#>        ||         Repos:
#>        ||           * https://mrc-ide.github.io/drat/
#>        XX           * https://cloud.r-project.org
#>        XX           * https://mrc-ide.github.io/didehpc-pkgs
#>        XX         Packages:
#>        XX           * context
#>        OO           * dde
#>        `'
#>
#> v Updated metadata database: 5.45 kB in 2 files.
#>
#> i Updating metadata database
#> v Updating metadata database ... done
#> i Getting 1 pkg (481.50 kB), 1 cached
#> v Got dde 1.0.3 (source) (180.79 kB)
#> v Got ring 1.0.0 (windows) (479.48 kB)
#> v Installed ring 1.0.0  (641ms)
#> i Building dde 1.0.3
#> v Built dde 1.0.3 (36.1s)
#> v Installed dde 1.0.3  (516ms)
#> v Summary:   2 new   10 kept  in 37.2s
#> Done!
```

If you want to add your packages to one of these repositories, please talk to Rich. You will need to increase your version number at each change (typically each merge into main/master) for the installation to notice that you have made changes.

## Install packages directly from GitHub (or similar)

We use [`pkgdepends`](https://r-lib.github.io/pkgdepends/) as the engine for installing packages from exotic locations. This is a problem that is slightly more complicated than it seems because the resolution of the dependencies are not always unambiguous, particularly with networks of dependent packages.

The basic idea is this. Suppose we want to install the [`rfiglet`](https://github.com/richfitz/rfiglet) package, which is not on CRAN. We use the "Remotes"-style reference `richfitz/rfiglet` as an entry to `conan_sources` so that `didehpc` knows where to install `rfiglet` from:


```r
src <- conan::conan_sources("richfitz/rfiglet")
ctx <- context::context_save(root, packages = "rfiglet", package_sources = src)
#> [ open:db   ]  rds
#> [ save:id   ]  64b4b09d2a42166d9c814f8b6f3bd0c0
#> [ save:name ]  juvenal_roebuck
```

Note that we still list `rfiglet` within the `packages` section of `context::context_save` as that is what is used to load the package.

If you want to be even more explicit you can use `github::richfitz/rfiglet` as the reference, and you can add references such as `richfitz/rfiglet@d713c1b8` to point at a particular commit, branch or tag.


```r
obj <- didehpc::queue_didehpc(ctx)
#> Loading context 64b4b09d2a42166d9c814f8b6f3bd0c0
#> [ context   ]  64b4b09d2a42166d9c814f8b6f3bd0c0
#> [ library   ]  rfiglet
#> [ namespace ]
#> [ source    ]
#> Running installation script on cluster
#>   ,:\      /:.
#>  //  \_()_/  \\
#> ||   |    |   ||  CONAN THE LIBRARIAN
#> ||   |    |   ||  Library:   Q:\didehpc\20210420-102851\pkgs\lib\windows\4.0
#> ||   |____|   ||  Bootstrap: T:\conan\bootstrap\4.0
#>  \\  / || \  //   Cache:     Q:\didehpc\20210420-102851\pkgs\conan\cache/pkg
#>   `:/  ||  \;'    Policy:    lazy
#>        ||         Repos:
#>        ||           * https://cloud.r-project.org
#>        XX           * https://mrc-ide.github.io/didehpc-pkgs
#>        XX         Packages:
#>        XX           * context
#>        XX           * rfiglet
#>        OO           * richfitz/rfiglet
#>        `'
#> i Loading metadata database
#> v Loading metadata database ... done
#>
#> ! Using bundled GitHub PAT. Please add your own PAT using `gitcreds::gitcreds_set()`.
#> i No downloads are needed, 1 pkg is cached
#> v Got rfiglet 0.2.0 (source) (144.05 kB)
#> i Packaging rfiglet 0.2.0
#> v Packaged rfiglet 0.2.0 (3.9s)
#> i Building rfiglet 0.2.0
#> v Built rfiglet 0.2.0 (2.9s)
#> v Installed rfiglet 0.2.0 (github::richfitz/rfiglet@d713c1b) (594ms)
#> v Summary:   1 new   10 kept  in 3.5s
#> Done!
```

## Install private packages

To install a private package, first make a local copy of the package somewhere on your system. Then you need to build a _source_ copy of this package (this will have a file extension of `tar.gz`).

For example, suppose that the path `~/Documents/src/defer` contains a copy of your sources that you want to install, you could write:


```r
path <- pkgbuild::build("~/Documents/src/defer", ".")
#>      checking for file ‘/home/rich/Documents/src/defer/DESCRIPTION’ ...  ✔  checking for file ‘/home/rich/Documents/src/defer/DESCRIPTION’
#>   ─  preparing ‘defer’:
#>      checking DESCRIPTION meta-information ...  ✔  checking DESCRIPTION meta-information
#>   ─  checking for LF line-endings in source and make files and shell scripts
#>   ─  checking for empty or unneeded directories
#> ─  building ‘defer_0.1.0.tar.gz’
#>
#>
```

The second argument (`.`) is the directory that the built package will be created in. This must be in your working directory. You might find using something like `pkgs` as a destination helps keeps things tidy. (You may want to use the `vignettes = FALSE` argument to speed this process up if your package includes slow-to-run vignettes as they will be of no use on the cluster).


```r
file.info(path)
#>                      size isdir mode               mtime               ctime
#> ./defer_0.1.0.tar.gz 3810 FALSE  755 2021-04-20 10:31:56 2021-04-20 10:31:56
#>                                    atime  uid  gid uname grname
#> ./defer_0.1.0.tar.gz 2021-04-20 10:31:56 1000 1000  rich   rich
```

Then construct your package sources passing in the **relative** path to your package. We can use the `path` variable here, or you could write ./defer_0.1.0.tar.gz directly, or something like local::defer_0.1.0.tar.gz. If you have multiple packages you can pass a vector in.


```r
src <- conan::conan_sources(path)
ctx <- context::context_save(root, packages = "defer", package_sources = src)
#> [ open:db   ]  rds
#> [ save:id   ]  67a2219cc6503939eb8667192e42ba45
#> [ save:name ]  evolutional_erne
```

when you construct the context, this package will be installed for you


```r
obj <- didehpc::queue_didehpc(ctx)
#> Loading context 67a2219cc6503939eb8667192e42ba45
#> [ context   ]  67a2219cc6503939eb8667192e42ba45
#> [ library   ]  defer
#> [ namespace ]
#> [ source    ]
#> Running installation script on cluster
#>   ,:\      /:.
#>  //  \_()_/  \\
#> ||   |    |   ||  CONAN THE LIBRARIAN
#> ||   |    |   ||  Library:   Q:\didehpc\20210420-102851\pkgs\lib\windows\4.0
#> ||   |____|   ||  Bootstrap: T:\conan\bootstrap\4.0
#>  \\  / || \  //   Cache:     Q:\didehpc\20210420-102851\pkgs\conan\cache/pkg
#>   `:/  ||  \;'    Policy:    lazy
#>        ||         Repos:
#>        ||           * https://cloud.r-project.org
#>        XX           * https://mrc-ide.github.io/didehpc-pkgs
#>        XX         Packages:
#>        XX           * context
#>        XX           * defer
#>        OO           * local::./defer_0.1.0.tar.gz
#>        `'
#> i Loading metadata database
#> v Loading metadata database ... done
#> i No downloads are needed, 1 pkg is cached
#> v Got defer 0.1.0 (source) (3.81 kB)
#> i Building defer 0.1.0
#> v Built defer 0.1.0 (2s)
#> v Installed defer 0.1.0 (local) (422ms)
#> v Summary:   1 new   10 kept  in 2.4s
#> Done!
```

## Troubleshooting package installation

### Local copies

You must have local copies of all packages installed (i.e., on the machine that is submitting the jobs). This is because we use some information about the packages to work out what can be run on the cluster. If you see a message like this when creating the queue object:

```
Loading context d1b3973bef7762b8d4d4ff5cbe090b2c
[ context   ]  d1b3973bef7762b8d4d4ff5cbe090b2c
[ library   ]  rfiglet
Error in library(p, character.only = TRUE) :
  there is no package called ‘rfiglet’
```

it means that you do not have the package installed *locally* and you should install it before continuing.

### File locking

You cannot upgrade packages while you have cluster jobs running. The reason for this is [file locking](https://en.wikipedia.org/wiki/File_locking); any cluster job running has a copy of the package loaded and will prevent deletion. Unfortunately the installation will delete quite a lot of the package before it realises that it is locked, which causes all sorts of problems.

Typically if you hit this you will see a "permission denied" error concerning a dll. Once this has happened you should be prepared for any queued jobs to fail.

To avoid, if upgrading packages, use a new context root.

## More control over the process

The package installation may seem a bit magic but you can tame it a little.

When constructing your queue object, you can control how provisioning will occur with the `provision` argument. The default is to check to see if any packages listed in your context's `packages` argument are missing and only then do installation.

If you pass `provision = "fake"` it will leave your library alone no matter what. Alternatively pass `provision = "upgrade"` to try and upgrade packages, or `provision = "later"` to skip this step for now. You can't submit jobs while your package installation looks incomplete.

If you want to add additional things into the library without running the full provisioning (which might upgrade all sorts of things) you can use the `install_packages()` method on the object. This ignores the contents of your `conan_sources` and you pass directly in the `pkgdepends`-style references; see [the `pkgdepends` documentation](https://r-lib.github.io/pkgdepends/reference/pkg_refs.html) for the myriad options here. Examples of usage include:

Install the latest version of a CRAN package

```r
obj$install_packages("data.table")
```

Install a GitHub package

```r
obj$install_packages("richfitz/stegasaur")
```

Install some local package from a `.tar.gz` file

```r
obj$install_packages("local::mypkg_0.1.2.tar.gz")
```

You can possibly use this interface (along with `provision = "fake"`) to manipulate your package installation fairly flexibly.

## Installation failure / the wrong versions have been selected

It is possible to end up in a situation where `pkgdepends` can't resolve your dependencies, or where in resolving dependencies an unwanted version of a package was installed. Please let Rich know with enough detail for him to reproduce the example himself:

* A copy of the code that runs up to `didehpc::queue_didehpc(...)` covering things like `context::context_save()` and `conan::conan_sources()`
* Copies of any manually built `.tar.gz` files that you are using
* A full copy of the log
